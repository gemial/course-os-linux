Модуль os в Python


:date: 2022-05-07
:summary: Лабораторная работа "Модуль OS Python на Linux"
:status: published
:author: Корчевая О. Е. 

.. contents:: Оглавление
   :depth: 2

Модуль os позволяет Python выполнять многие операции с файлами и папками, которые вы обычно выполняете в командной строке Linux. Модуль предоставляет функции для работы с операционной системой, при этом поведение функций не зависит от ОС. Модуль так же позволяет работать с файлами, папками, а так же со многими другими объектами операционной системы, как, например, процессы или переменные окружения. Познакомимся с самыми популярнфми функциями. 

**В ходе данной лабораторной работы мы научимся:**

1.	Работать со значениями среды

2.	Менять каталоги и находить тот, который в данный момент является рабочим

3.	Создавать и удалять папки и файлы

4.	Переименовывать папки и файлы

5.	Открывать файл в соответствующей ему программе

6.	Работать с путями

Для начала работы необходимо подключить модуль обычной командой import

.. code-block:: python

	>>> import os

Основные функции для работы с модулем
##########################################################

os.name
=========================================================

Модуль os обладает как вызываемыми функциями, так и обычными значениями. В случае с os.name, речь идет только о значениях. При доступе к os.name, вы получите информацию о том, с какой платформой вы работаете. Вам откроются следующие значения: ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’, ‘riscos’. Давайте посмотрим на то, что выйдет, если запустить его на Windows 7:

.. code-block:: python

	>>> os.name
	
	'posix'

Это говорит нам о том, что наш экземпляр Python работает в окне Windows. Как мы об этом узнали? Майкрософт начали называть свою операционную систему NT много лет назад. Например, Windows 7 также носит имя Windows NT 6.1.

os.environ, os.getenv() и os.putenv()
=========================================================

Значение os.environ известно как объект мэппинга (сопоставления), который работает со словарем переменных пользовательской среды. Возможно вы не знали, но каждый раз, когда вы пользуетесь своим компьютером, некоторые переменные среды уже установлены.


Это дает вам полезную информацию, такую как количество процессоров, тип ОЗУ, имя компьютера, и так далее. Посмотрим, что мы сможем узнать о нашем компьютере:

.. code-block:: python

	>>> print(os.environ)
	
.. code-block:: txt
	
	environ({'TERM_PROGRAM': 'Apple_Terminal', 
	'SHELL': '/bin/bash', 
	'TERM': 'xterm-256color', 
	'TMPDIR': '/var/folders/hv/p9v314d106z3tqjyxvn5hfm40000gn/T/',
	'CONDA_SHLVL': '0', 
	'TERM_PROGRAM_VERSION': '433', 
	'TERM_SESSION_ID': '156EFB08-2191-40AC-89C8-A80DA200875F', 
	'USER': 'evgenij',
	'CONDA_EXE': '/Users/evgenij/opt/anaconda3/bin/conda', 
	'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.lJbr3lVPMb/Listeners', 
	'_CE_CONDA': '', 
	'PATH': '/Users/evgenij/opt/anaconda3/condabin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin', 
	'PWD': '/Users/evgenij', 
	'LANG': 'ru_RU.UTF-8', 
	'XPC_FLAGS': '0x0', 
	'_CE_M': '', 
	'XPC_SERVICE_NAME': '0', 
	'SHLVL': '1', 
	'HOME': '/Users/evgenij',
	'CONDA_PYTHON_EXE': '/Users/evgenij/opt/anaconda3/bin/python',
	'LOGNAME': 'evgenij', '_': '/Library/Frameworks/Python.framework/Versions/3.7/bin/python3',
	'__CF_USER_TEXT_ENCODING': '0x1F5:0x7:0x31', 
	'__PYVENV_LAUNCHER__': '/Library/Frameworks/Python.framework/Versions/3.7/bin/python3'})

Ваши данные будут отличаться от моих, так как конфигурация компьютера у всех немного отличается, однако вы определенно увидите большое количество совпадений. Как вы могли заметить, работа функции вернула словарь. Это значит, что вы можете получить доступ к значениям среды, пользуясь обычными словарными методами. Например обрвщаться к нему по ключу:

.. code-block:: python

	>>> print(os.environ["TMPDIR"]) 
	
.. code-block:: txt
	
	/var/folders/hv/p9v314d106z3tqjyxvn5hfm40000gn/T/

Вы также можете использовать функцию os.getenv для доступа к этой переменной:

.. code-block:: python

	>>> print(os.getenv("TMPDIR")) 
	
.. code-block:: txt
	
	/var/folders/hv/p9v314d106z3tqjyxvn5hfm40000gn/T/

Полезность использования os.getenv() вместо словаря os.environ заключается в том, что если вы находитесь в положении, когда вам нужно получить доступ к переменной среды, которая не существует, функция getenv попросту ничего не сделает. Если вы попытаетесь сделать то же самое, пользуясь os.environ, вы получите уведомление об ошибке. Давайте попробуем на примере:

.. code-block:: python

	>>> print(os.environ["TMP2"])
	
.. code-block:: txt
	
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	  File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/os.py", line 678, in __getitem__
	    raise KeyError(key) from None
	KeyError: 'TMP2'
  
  
os.chdir() и os.getcwd()
=========================================================

Функция os.chdir позволяет нам вносить изменения в каталоге, который мы в данный момент используем в сессии. Если вам нужно знать, какой путь вы в данный момент используете, для этой нужно вызвать os.getcwd(). Попробуем воспользоваться обоими модулями:

.. code-block:: python

	>>> os.getcwd()	

	
	'/Users/evgenij'
	

  os.chdir(r"C:\Users\mike\Documents")
  
  print(os.getcwd()) 
  # C:\\Users\\mike\\Documents
  
Мы открыли директорию по умолчанию в Python, после запуска данного кода в IDLE. После этого мы изменили папки, при помощи os.chdir(). Наконец, мы вызывали os.getcwd() еще раз, чтобы убедиться, что все изменения были выполнены правильно.

Работа с папками и файлами 
#####################################

os.mkdir() и os.makedirs()
=========================================================

Как вы могли догадаться, эти два метода уже знакомы нам и используются для создания папок. Первая, os.mkdir(), позволяет создать одну папку. Попробуем:

.. code-block:: python

	>>> import os
	>>> path = r'C:\Users\evjenij\Documents'
	>>> os.mkdir(path)

Первая строка кода создает папку под названием test в определенном каталоге. Вы можете использовать эти модули в предыдущем разделе, чтобы узнать, где именно вы запустили свой код, на случай, если вы забыли. Во втором примере мы назначили путь к переменной, затем к os.mkdir(). Это позволяет вам создать папку в любой точке вашей системы, где есть доступ. Функция os.makedirs() создает промежуточные папки в пути, если их там нет. В целом, это значит, что вы создали путь, в котором размещены папки. Данное решение удобно, когда есть необходимость создания журнала, с датированной структурой, например Год\Месяц\День. Давайте взглянем на пример:

.. code-block:: python

 >>> path = r'C:\Users\evjenij\Documents\pytest\2014\02\19'
 >>> os.makedirs(path)
  
Что произошло? Этот код просто создал кучу папок! Если в вашей системе все еще есть папка pytest, то в ней появится папка 2014, в которой также есть папка, в которой, удивительно, находится еще одна. Попробуйте сами, воспользовавшись рабочим путем в вашей системе.


os.remove() и os.rmdir()
=========================================================

Функции os.remove() и os.rmdir() используются для удаления файлов и каталогов соответственно. Посмотрим на os.remove():

.. code-block:: python

 >>> os.remove("test.txt")
  
Этот фрагмент кода пытается удалить файл под названием test.txt из вашего рабочего каталога. Если модуль не может найти файл, должно появиться уведомление о той или иной ошибке. Ошибка также возникнет, если файл уже используется (другими словами закрыт), или у вас нет разрешения для удаления данного файла. Возможно, вы хотите проверить os.unlink, который выполняет ту же функцию. Термин unlink – привычное для Unix название данной процедуры. Взглянем на пример работы os.rmdir():

.. code-block:: python

  >>> os.rmdir("pytest")
  
Данный код попытается удалить каталог под названием pytest из каталога, используемого в данный момент в работе. В случае, если это удалось, каталог pytest исчезнет. Ошибка может возникнуть, если каталога с таким названием не существует, если у вас нет разрешения на его удаление, или если каталог не пустой. Вам возможно хочется взглянуть на os.removedirs(), который может удалить пустые вложенные каталоги.


os.rename(src, dst)
=========================================================

Функция os.rename() применяется тогда, когда нужно переименовать файл или папку. Посмотрим на примере:

.. code-block:: python

  >>> os.rename("test.txt", "pytest.txt")
  
В этом примере, мы указали os.rename на то, что нужно переименовать файл под названием test.txt на pytest.txt. Это произойдет в каталоге, с которым мы в данный момент работаем. Ошибка может возникнуть в том случае, если вы попытаетесь переименовать несуществующий файл, или если у вас нет доступа к данной операции. Также существует функция os.renames, которая меняет название папки или файла соответственно.


os.startfile()
=========================================================

Метод os.startfile() позволяет нам «запустить» файл в привязанной к нему программе. Другими словами, мы можем открыть файл вместе с привязанной к нему программой, как когда вы открываете файл PDF двойным щелчком, и он открывается в программе Adobe Reader. Попробуем:

.. code-block:: python

  >>> os.startfile(r'C:\Users\evjenij\Documents\labels.pdf')
  
В данном примере мы прошли полный путь к модулю os.startfile, который указывает на открытие файла под названием labels.pdf. На моем компьютере данная функция открывает файл PDF в программе Adobe Reader. Попробуйте открыть файлы PDF, MP3 или фотографии на своем компьютере при помощи данного метода, чтобы увидеть как он работает.

os.walk()
=========================================================

Метод os.walk() дает нам возможность для итерации на корневом уровне пути. Это значит, что мы можем назначить путь к этой функции и получить доступ ко всем её подкаталогам и файлам. Используем одну из папок Python, при помощи которой мы можем проверить данную функцию. Мы используем C:\Python27\Tools

.. code-block:: python

  import os

  path = r'C:\Python3\Tools'

  for root, dirs, files in os.walk(path):
      print(root)
      
Результат работы:

.. code-block:: python

  C:\Python27\Tools
  C:\Python27\Tools\i18n
  C:\Python27\Tools\pynche
  C:\Python27\Tools\pynche\X
  C:\Python27\Tools\Scripts
  C:\Python27\Tools\versioncheck
  C:\Python27\Tools\webchecker
  
  
Функции для работы со ссылками
##########################################

os.symlink()
=========================================================

Создаёт символическую ссылку на объект.

Синтаксис:

.. code-block:: python

	os.symlink(src, dst, target_is_directory = False, *, dir_fd = None)

Параметры:

**src**: объект, похожий на путь, представляющий путь к файловой системе. Это путь к исходному файлу, для которого будет создана символическая ссылка.

**dst**: объект, похожий на путь, представляющий путь к файловой системе. Это путь к целевому файлу, в котором будет создана символическая ссылка.

**target_is_directory (необязательно)**: значение этого параметра по умолчанию — False. Если указанный целевой путь является каталогом, его значение должно быть True.

**dir_fd (необязательно)**: дескриптор файла, ссылающийся на каталог.

**Возвращаемое значение**: этот метод не возвращает никакого значения.

os.link()
=========================================================

Метод os.link() создает жесткую ссылку, указывающую на src с именем dst . Этот метод очень полезен для создания копии существующего файла

Синтаксис:

.. code-block:: python
	
	os.link(src, dst)

Параметры:

**src**:это путь к исходному файлу, для которого будет создана жесткая ссылка.

**dest**:это путь к целевому файлу, по которому будет создана жесткая ссылка.

**Возвращаемое значение**: этот метод не возвращает никакого значения.

Отличия жесткой и символической ссылок
===========================================

**Сиволические** **ссылки**

Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.

Особенности:
~~~~~~~~~~~~~~~~~~~~~~~~

Могут ссылаться на файлы и каталоги.

После удаления, перемещения или переименования файла становятся недействительными.

Права доступа и номер inode отличаются от исходного файла.

При изменении прав доступа для исходного файла, права на ссылку останутся неизменными.

Можно ссылаться на другие разделы диска.

Содержат только имя файла, а не его содержимое.

Теперь давайте рассмотрим жесткие ссылки.

**Жесткие** **ссылки**

Этот тип ссылок реализован на более низком уровне файловой системы. Файл размещен только в определенном месте жесткого диска. Но на это место могут ссылаться несколько ссылок из файловой системы. Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. 

Особенности:
~~~~~~~~~~~~~~~~~~~~~~~~

Работают только в пределах одной файловой системы.

Нельзя ссылаться на каталоги.

Имеют ту же информацию inode и набор разрешений что и у исходного файла.

Разрешения на ссылку изменяться при изменении разрешений файла.

Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

  

Подмодуль os.path
#######################

Подмодуль os.path модуля os имеет широкий ряд встроенных преимуществ. Ознакомимся со следующими функциями:

•	basename

•	dirname

•	exists

•	isdir and isfile

•	join

•	split


os.path.basename
=========================================================

Функция basename вернет название файла пути. Пример:

.. code-block:: python

  import os

  os.path.basename(r'C:\Python27\Tools\pynche\ChipViewer.py')
  # ChipViewer.py
  
Это очень полезная функция, особенно в тех случаях, когда нужно использовать имя файла для наименования того или иного связанного с работой файла, например лог-файл. Такая ситуация возникает часто при работе с файлами данных.

os.path.dirname
=========================================================

Функция dirname возвращает только часть каталога пути. Это проще понять, если мы взглянем на пример кода:

.. code-block:: python

  import os

  print( os.path.dirname(r'C:\Python27\Tools\pynche\ChipViewer.py') )
  # C:\\Python27\\Tools\\pynche
  
В данном примере мы просто возвращаем путь к каталогу. Это также полезно, когда вам нужно сохранить другие файлы рядом с тем, который вы обрабатываете в данный момент. Как и в случае с лог-файлом, упомянутым выше.

os.path.exists
=========================================================

Функция exists говорит нам, существует ли файл, или нет. Все что вам нужно, это указать ему путь. Взглянем на пример:

.. code-block:: python

  import os

  os.path.exists(r'C:\Python27\Tools\pynche\ChipViewer.py') # True

  os.path.exists(r'C:\Python27\Tools\pynche\fake.py') # False
  
В первом примере, мы указали функции exists настоящий путь, на что она указывает как True. Это говорит о том, что данный путь существует. Во втором примере, мы указали неправильный путь, от чего функция указывает нам на это сообщением False.

os.path.isdir / os.path.isfile
=========================================================

Методы isdir и isfile тесно связаны с методом exists, так как они также тестируют присутствие или отсутствие файлов или папок на тех или иных путях. Однако, isdir проверяет только пути к папкам, а isfile, соответственно, к файлам. Если вам нужно проверить путь, и не важно, папка это или файл, проще будет воспользоваться методом exists. В любом случае, взглянем на пару примеров:

.. code-block:: python

  import os

  os.path.isfile(r'C:\Python27\Tools\pynche\ChipViewer.py') 
  # True

  os.path.isdir(r'C:\Python27\Tools\pynche\ChipViewer.py') 
  # False

  os.path.isdir(r'C:\Python27\Tools\pynche') 
  # True

  os.path.isfile(r'C:\Python27\Tools\pynche') 
  # False
  
Уделите особое внимание данным примерам. В первом мы указали путь к файлу и проверили, является ли этот путь в действительности файлом. Затем, во втором примере, мы проделали то же самое, но в контексте папки. Вы можете лично ознакомиться с результатами. После этих двух примеров, мы немного изменили условия, указав путь к папке для обеих функций. Эти примеры наглядно демонстрируют то, как эти функции работают.

os.path.join
=========================================================

Метод join позволяет вам совместить несколько путей при помощи присвоенного разделителя. К примеру, в Windows, в роли разделителя выступает бэкслэш (косая черта, указывающая назад), однако в Linux функция разделителя присвоена косой черте, указывающей вперед (forward slash). Как это работает:

.. code-block:: python

  import os

  print( os.path.join(r'C:\Python27\Tools\pynche', 'ChipViewer.py') )
  # C:\\Python27\\Tools\\pynche\\ChipViewer.py
  
В данном примере мы совместили путь каталога и файла вместе, для получения рабочего пути. Обратите внимание на то, что метод join не указывает на то, какой результат в итоге вышел.

os.path.split
=========================================================

Метод split разъединяет путь на кортеж, который содержит и файл и каталог. Взглянем на пример:

.. code-block:: python

  import os

  print( os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py') )
  # ('C:\\Python27\\Tools\\pynche', 'ChipViewer.py')
  
В данном примере показано, что происходит, когда мы указываем путь к файлу. Теперь взглянем на то, что происходит, если в конце пути нет названия файла:

.. code-block:: python

  import os

  print( os.path.split(r'C:\Python27\Tools\pynche') )
  # (‘C:\Python27\Tools’, ‘pynche’)
  
Как видите, данная функция берет путь и разъединяет его таким образом, что подпапка стала вторым элементом кортежа с остальной частью пути в первом элементе. Напоследок, взглянем на бытовой случай использования split:

.. code-block:: python

  import os

  dirname, fname = os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py')
  print(dirname)
  # C:\\Python27\\Tools\\pynche

  print(fname)
  # ChipViewer.py
  
В данном примере указано, как сделать множественное назначение. Когда вы разъединяете путь, он становится кортежем, состоящим из двух частей. После того, как мы опробовали две переменные с левой части, первый элемент кортежа назначен к первой переменной, а второй элемент к второй переменной соответственно.

Задачи на использование функций
###############################################

Задача 1:
=========================================================

Напишите программу, которая выводит 'Hello, $USER!', где $USER - имя пользователя. Пользоваться print() запрещено.

Задача 2:
=========================================================

Напишите программу, которая выводит дерево файлов по заданному пути. В ней должны быть:

а) фильтр по названиям

б) вывод типа файла: является ли файл символической ссылкой или является обычным файлом

Задача 3:
=========================================================
Напишите программу, которая создаст журнала (отдельную папку), с датированной структурой, например Год\Месяц\День, в которой будут 2021, 2022 года и летние месяцы каждого года. Создайте жесткую ссылку в папке 2022 года на август месяц 2021 года и символическую ссылку на июнь и июль 2021 года. Удалите папку с 2021 годом и опишите как будут вести себя ссылки. Что будет если не удалять папку, а перенести ее в другое место из основного журнал? Какие ссылки в этом случае бкдкт рабочими?

Задача 4:
=========================================================

Петя только начал изучать программирование и пока не научился пользоваться командой git clone, поэтому скачал несколько репозиториев с Github в .zip формате. Но вот незадача: файлы программ не являются исполняемыми. Есть несколько .zip архивов, в них содержатся файлы необходимых проектов на языке Python. Напишите программу, которая разархивирует проекты в отдельные папки с тем же названием проектов и сделает все Python файлы исполняемыми.

Задача 5:
=========================================================

Напишите программу, которая проверяет, есть ли в переменных окружения заданный путь. Если переменная есть, вывести название переменной, если ее нет - создать с именем 'OS_PRACTICE

